# Physics Simulation
#### Video Demo: https://youtu.be/m0tCZBC9pTw
#### Description:
This physics simulation is intended to be as realistic as possible. To ensure that, the program is backed by physics and mathematics; additionally, certain restrictions for user input were set to adhere to the essence of the simulation. The entire simulation is set in an HTML web server, with Flask and CSS running in the background to provide dynamism and aesthetic appeal. JavaScript controls the animation and the calculations behind it all.

In the `project` folder, there are two separate folders: `templates` (for the HTML files that make up the project's website interface) and `static` (to store CSS files, images, and JavaScript code). `static` has three more files inside: `css`, `images`, and `js_files`. There is also an independent `app.py` in `project`, a Python file that ties together the entire project with Flask.

`templates` has four files, each written in HTML, Jinja, and JavaScript. The website's main page is `index.html`. `layout.html` provides the skeleton structure for all the HTML code, including the column of pages at the left of the screen. `cliff.html` and `cannon.html` divide the project into two main routes.

The first portion, excluded from the demonstration video due to the time limit, is set in `cliff.html` and is decorated by `cliff.css`. It simulates an object falling from a cliff. (As the mass or weight of the object does not affect how fast it falls, the object is simply an unspecified ball. Air resistance is disregarded for this project.) On the page's top right, there are input fields, where the user may specify the cliff's height, the unit of time, and the unit of distance. Directly under the input fields are two buttons. A model cliff, a rectangular boundary that marks the ground, and a ball complete the setting of the first simulation. Upon the user hitting the 'run' button, the JavaScript script of `cliff.html` passes the user's input to `formulae.js` in `static/js_files`. The function `fallingBall()` returns how long the object takes to hit the ground; the time is displayed on the top of the page. `cliff.html` additionally reaches out to `animations.js`, which is also in `static/js_files`. There, the `fallingBallAnim()` function animates the ball's descent down the screen until it hits the ground.

The animation of the cliff simulation fails to capture the object's movements at specific periods, as the descent is merely straight down from the model cliff. Therefore `cliff.html` displays a 'plot' button along with the 'run' button. When the 'plot' button is clicked, the input form is submitted to `app.py` using the POST method. `app.py`, adhering to physics formulae, plots a graph that describes the fall. The x-axis is the time passed, while the y-axis is the object's height at that moment. The graph appears as a pop-up window.

The second part, established by `cannon.html` and fashioned by a CSS file of the same name, models the trajectory of a cannonball launched from a cannon. The cannon was removed (specific details below, in the following paragraph) in favor of a simple arrow (`arrow.svg` from `static/images`). The arrow and the cannonball are placed at the bottom left corner of the `area` div, which represents the ground of the simulation as a long horizontal line. Again, there are input fields on the right, where the user inputs the initial velocity of the cannonball, the angle of the cannon, and the units of distance and time. The JavaScript section of `cannon.html` finds the initial horizontal and vertical velocities by applying trigonometry to the given information. As in the cliff simulation, `formulae.js` is the file that receives the acceleration of gravity (which changes when the unit of distance is changed), the horizontal velocity, and the vertical velocity. The function `movingBall()` produces the time taken, total horizontal distance covered, and maximum height. `cannon.html`, upon receiving the data, hands it to `animations.js`. Its second function, `movingBallAnim()`, receives `angle` (the angle of the cannon), `max_x` (total horizontal distance covered), and `max_y` (the maximum height reached). The function then models the cannonball's trajectory as a parabolic function. The vertex of the equation is at (`max_x/2`, `max_y`) when we set the cannonball's starting point as the origin. However, `max_x` and `max_y` are real-world values. If the simulation uses those exact values, the movement of the cannonball may be too big or too small for users to observe conveniently. Therefore, `max_x` and `max_y` are scaled by a value `scale`, a varying value computed so that the course of the cannonball does not escape the screen nor move minutely. Using the vertex form of a quadratic equation, the equation becomes `y = a*(x-(max_x/2))^2 + max_y`. And since `max_x` and `max_y` are scaled, the equation is usable for the animation. When we insert (0, 0), a known point of the parabola, into the equation, we find that `a = (-max_y) / peak_x^2)`. With the complete function, the animation runs. The arrow tilts, angled according to the user input. As the cannonball moves, the coordinates of its location are simultaneously displayed. The coordinates are real-world values, not the scaled values relative to the screen.

The cannon simulation originally contained a cannon. However, as the cannon tilted, the cannonball had to go along, leading to complex calculations. Although it functioned, truncation errors and technical fragments made the cannonball relocate in places slightly ajar from the cannon's muzzle. Because the cannon was far from the essence of the project, it became a distraction and was removed in favor of an arrow. Additionally, the domain of the cannon simulation's angle value was limited to 15 to 60 degrees, because other values were irrational.